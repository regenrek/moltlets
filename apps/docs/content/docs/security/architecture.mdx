---
title: Architecture
description: Trust zones, bootstrapping boundaries, and network posture.
---

This page describes the main trust zones in a Clawlets project and why they exist. The
intent is to keep it obvious which data can be committed, which must stay local, and
which lives on the servers.

## Trust zones

There are three primary zones (plus a Git remote):

<Mermaid
  chart={`flowchart LR
  subgraph Local["Your machine"]
    direction LR
    Repo["Your local Clawlets project"]
    Runtime["Local state (.clawlets, gitignored)"]
    Repo --- Runtime
  end

  GH["Git remote (recommended private)"]
  Ops["Bootstrap + ops (SSH)"]
  Server["On-server runtime"]

  Repo --> GH
  GH --> Repo
  Repo -.-> Ops
  Ops -.-> Server
`}
/>

This is a “where data lives” map. Servers do not need Git credentials. For how data
moves during bootstrap vs updates, see **Day 0 vs Day N** below.

### Git repo (recommended private)

Clawlets works best when the project repo stays private. While it is possible to run
from a public repo, the repo contains infrastructure metadata (hosts, topology, and
operational defaults) even when secrets are encrypted.

- `flake.nix` / `flake.lock`: build graph, imports the Clawlets framework
- `fleet/clawlets.json`: fleet config (no secrets)
- `secrets/`: SOPS-encrypted secrets (intended to be committed)

<Callout type="warning" title="Recommendation: keep the repo private">
A public repo can work if secrets stay SOPS-encrypted and `.clawlets/` never gets
committed, but a private repo reduces accidental exposure of infra metadata.
</Callout>

### Local `.clawlets/` folder (gitignored)

This folder lives on your machine and must not be committed. By default it is
`.clawlets/` (you can override it with `--runtime-dir`).

- `.clawlets/keys/operators/*.agekey`: operator private keys (never commit)
- `.clawlets/extra-files/<host>/...`: bootstrap payload generated by `clawlets secrets init`
- `.clawlets/infra/opentofu/<host>/...`: provisioning state (gitignored)

### On-server runtime

Servers contain the actual decrypted runtime state and the local control-plane socket.

- `/var/lib/sops-nix/key.txt`: host age key
- `/var/lib/clawlets/secrets/hosts/<host>/`: encrypted secrets files (SOPS)
- `/run/secrets/**`: decrypted materialized secrets at runtime (owned by service users)
- `/run/clf/orchestrator.sock`: gateway-facing control-plane socket (group `clf-gateways`)
- `/var/lib/clf/orchestrator/state.sqlite`: orchestrator DB (job payloads/results + token hashes)

## Day 0 vs Day N

Clawlets has two different “movement” phases:

- **Day 0 (bootstrap)**: operator pushes a small, explicit payload to get the host into a
  state where it can run.
- **Day N (updates)**: host pulls signed desired-state manifests and switches itself.

### Day 0: Bootstrap (operator-driven)

Bootstrap is the only time you should be “pushing state” from your workstation to a
host. It installs NixOS and can seed the host with encrypted secrets and the host age
key via `nixos-anywhere --extra-files`.

<Mermaid
  chart={`graph TD
  Repo["Your local Clawlets project"] --> Payload[".clawlets extra-files"]
  Payload -->|nixos-anywhere extra-files| Host["Host secrets dir (encrypted)"]
`}
/>

After bootstrap, you can restrict SSH to tailnet-only access and operate primarily via
the updater and the dashboard/CLI.

### Day N: Updates (host-driven)

After bootstrap, hosts follow a signed desired-state manifest (pointer + immutable
manifest). A publisher (typically CI) builds the system and publishes:

- a NixOS system closure to a binary cache
- `latest.json` and `<releaseId>.json` (signed)
- optional encrypted secrets bundle referenced by `secrets.url`

Hosts periodically pull, verify, and apply these artifacts without needing Git
credentials.

<Mermaid
  chart={`graph TD
  Publisher["Publisher (CI)"] --> Cache["Binary cache"]
  Publisher --> BaseUrl["Release base URL (baseUrls)"]
  Updater["Host updater (root)"] --> BaseUrl
  Updater --> Cache
  Operator["Operator (optional)"] -.-> Updater
`}
/>

If you SSH in and run `clawlets server update apply`, you are only triggering the same
host updater service early. It is not a separate push-based deploy path.

## Experimental: Cattle (Hetzner) plugin

The Hetzner cattle workflow is optional. It is provided as a CLI plugin:

```bash
clawlets plugin add cattle
```

More details: [Hetzner Cattle](/plugins/hetzner-cattle).

<Callout type="warning" title="Experimental">
Cattle is not the common path yet. Expect workflows and flags to change.
</Callout>

When using cattle, VMs are bootstrapped via cloud-init `user_data`. That is convenient,
but it also defines the threat model for bootstrap credentials.

- `tailscale_auth_key` (written to tmpfs) so the VM can join the tailnet
- one-time bootstrap token + baseUrl so the VM can fetch runtime env from `clf-orchestrator`

<Callout type="warning" title="Assume user_data is readable">
Treat Hetzner `user_data` as accessible to anyone with Hetzner project/API access. Keep
bootstrap tokens short-lived and rotate tailnet join credentials regularly.
</Callout>

## Network posture

Clawlets expects a “bootstrap window” followed by a more restrictive steady state.

- SSH is key-only; passwords are for `sudo`/console only.
- Public SSH is temporary (bootstrap only; controlled by `sshExposure.mode`).

### Egress policy

Egress controls are about reducing accidental exposure and limiting what gateways can reach.

- Default mode blocks outbound SMTP ports (anti-spam only).
- Optional mode forces gateway services through a local HTTP proxy with a domain allowlist.
