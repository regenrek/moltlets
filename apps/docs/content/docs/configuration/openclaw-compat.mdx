---
title: OpenClaw compatibility
description: How Clawlets aligns with OpenClaw config.
---

Clawlets does **not** invent a second routing schema. It passes the OpenClaw
config through directly and enforces a small set of invariants.

## Where the OpenClaw config lives

OpenClaw config is embedded per bot inside the fleet file:

```json
{
  "fleet": {
    "bots": {
      "<bot>": {
        "openclaw": {
          "...": "raw OpenClaw config"
        }
      }
    }
  }
}
```

Clawlets reads `fleet.bots.<bot>.openclaw` and renders it into the on-host
gateway config.

## Invariants Clawlets enforces

Clawlets overrides a few keys for consistency and operational constraints. These are
the values that tie the runtime to the host layout and gateway policy:

- `gateway.mode = "local"`
- `gateway.bind` / `gateway.port`
- `gateway.auth` (always enabled)
- `agents.defaults.workspace`
- `agents.defaults.skipBootstrap`

The rest of the OpenClaw config is preserved as-is.

## Schema source (pinned vs live)

Clawlets ships a pinned OpenClaw schema that powers CLI validation and the UI editor.
The pinned schema is generated from a specific OpenClaw revision so validation stays
stable across installs.

Source of truth:
- `packages/core/src/assets/openclaw-config.schema.json` (generated)
- generator: `scripts/generate-openclaw-assets.ts` (points at the pinned `openclaw-src` rev)

- CLI: `clawlets openclaw schema fetch --host <host> --bot <bot>` to fetch live schema
- UI: "Use live schema" toggles to a gateway-fetched schema

The UI surfaces drift between:

- Pinned schema vs the project's pinned `nix-openclaw` rev
- Pinned schema vs upstream `nix-openclaw` main

## Upgrade guidance

When upgrading OpenClaw (via `nix-openclaw`):

1. Update the project flake input
2. Run `clawlets doctor` to catch schema drift
3. Apply updates to a staging host first
