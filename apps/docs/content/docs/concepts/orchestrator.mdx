---
title: Orchestrator
description: clf job queue and cattle spawner.
---

The orchestrator is the bot-facing control plane. Bots request work through `clf jobs`
without ever holding Hetzner credentials or long-lived provider keys.

Clawlets keeps privileges clear by splitting responsibilities:

- `clawlets`: operator/admin CLI (bootstrap, deploy, lockdown, server ops)
- `clf`: bot-facing control plane (jobs queue)

## Components

The orchestrator is composed of a queue, a daemon, and a bot-facing CLI:

- `packages/clf/queue`: SQLite queue + schemas (idempotency, leases, retry).
- `packages/clf/orchestrator`: daemon + worker loop + handlers.
- `packages/clf/cli`: `clf` CLI (bots call this).

## Transport + auth (default)

Bots and cattle talk to the orchestrator over different transports with different
constraints. Bots use a Unix socket protected by filesystem permissions, and cattle
fetch their runtime environment over tailnet-only HTTP.

- Bot → orchestrator: Unix socket HTTP
  - socket: `/run/clf/orchestrator.sock`
  - auth: filesystem perms (systemd socket `0660`, group `clf-gateways`)
- Cattle → orchestrator: tailnet-only HTTP (secrets env fetch)
  - endpoint: `GET /v1/cattle/env` (bearer token, one-time)
  - bind: tailnet (`tailscale0`) only (default `CLF_CATTLE_SECRETS_LISTEN_HOST=auto`)

No public ingress by default.

## Deployment (Pet host, NixOS)

The Clawlets framework ships a NixOS module for the orchestrator:

- module: `nix/modules/clf-orchestrator.nix`

Enable in your host config (project repo):

```nix
services.clfOrchestrator.enable = true;
```

Required secrets (sops, per host)
- `hcloud_token` (Hetzner API)
- `tailscale_auth_key` (cattle tailnet join key; tag-scoped + ephemeral recommended)
- provider keys wired via `fleet.secretEnv` (e.g. `ZAI_API_KEY -> z_ai_api_key`)

After deploy:

```bash
systemctl status clf-orchestrator.socket
systemctl status clf-orchestrator
ls -la /run/clf/orchestrator.sock
```

## CLI (bot-facing)

Bots enqueue jobs via the `clf` CLI. The queue enforces idempotency so a single
message or event cannot spawn duplicates if it retries.

Enqueue a cattle spawn:

```bash
clf jobs enqueue cattle.spawn \
  --requester maren \
  --idempotency-key <discord-message-id> \
  --persona rex \
  --task-file ./task.json \
  --ttl 2h \
  --json
```

Inspect jobs:

```bash
clf jobs list --requester maren --json
clf jobs show --job-id <jobId> --json
clf jobs cancel --job-id <jobId> --json
```

Notes
- Bots use `clf`. Do not grant bots access to the `clawlets` admin CLI.
- `withGithubToken` is operator-only today (via `clawlets cattle spawn --with-github-token`).

## Runtime state

Runtime state lives on the host so you can inspect it with standard tools.

- DB: `/var/lib/clf/orchestrator/state.sqlite` (SQLite WAL; contains job payloads/results + token hashes)
- Logs: `journalctl -u clf-orchestrator --since 10m`

## Job kinds (v1)

Today the queue handles cattle lifecycle operations:

- `cattle.spawn`: create Hetzner server from cattle image; inject persona + task; cattle fetches secrets env at runtime.
- `cattle.reap`: delete expired cattle servers (TTL label).

## Troubleshooting

Most issues are either a missing socket or an expired token.

- “connection refused” / “socket missing”
  - `systemctl status clf-orchestrator.socket`
  - verify caller is in `clf-gateways` group
- `GET /v1/cattle/env` 401
  - token expired or already used (one-time + TTL)
  - cattle didn’t join tailnet (bad `tailscale_auth_key`)
