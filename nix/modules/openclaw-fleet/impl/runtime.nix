{ config, lib, pkgs, defs, gatewayConfig }:

let
  inherit (defs)
    cfg
    getGatewayProfile
    resolveGatewayWorkspace
    resolveGatewayCredsDir
    mkSopsSecretFor
    buildEffectiveSecretEnv;

  inherit (gatewayConfig) mkGatewayConfig;

  resolveSecretEnv = profile:
    let
      baseEnv = buildEffectiveSecretEnv profile;
      allowlist = profile.secretEnvAllowlist or null;
    in
      if allowlist == null
      then baseEnv
      else lib.filterAttrs (k: _: lib.elem k allowlist) baseEnv;

  mkGatewaySkillSecrets = b:
    let
      profile = getGatewayProfile b;
      effectiveSecretEnv = resolveSecretEnv profile;
      secretEnvSecrets = builtins.attrValues effectiveSecretEnv;
      githubSecrets =
        lib.optional ((profile.github.privateKeySecret or null) != null) profile.github.privateKeySecret;
      allSecrets = lib.unique (lib.filter (s: s != null && s != "") (
        githubSecrets
        ++ secretEnvSecrets
      ));
    in
      builtins.listToAttrs (map (secretName: { name = secretName; value = mkSopsSecretFor secretName; }) allSecrets);

  mkTemplate = b:
    {
      "openclaw-${b}.json" = {
        owner = "gateway-${b}";
        group = "gateway-${b}";
        mode = "0400";
        # Important: keep template content pure at eval time.
        # `builtins.readFile (pkgs.formats.json.generate ...)` forces a local build/eval-store write,
        # which breaks remote-build workflows on hosts that reject unsigned local store paths.
        content = builtins.toJSON (mkGatewayConfig b);
      };
      "openclaw-${b}.env" =
        let
          profile = getGatewayProfile b;
          effectiveSecretEnv = resolveSecretEnv profile;
          envKeys = lib.sort (a: b: a < b) (builtins.attrNames effectiveSecretEnv);
          lines = lib.concatLists (map (k:
            let
              secretName = toString (effectiveSecretEnv.${k} or "");
            in
              if secretName == "" then [ ] else [ "${k}=${toString config.sops.placeholder.${secretName}}" ]
          ) envKeys);
          body = lib.concatStringsSep "\n" ([ "# Generated by clawlets (sops-nix template)" ] ++ lines) + "\n";
        in
          {
            owner = "gateway-${b}";
            group = "gateway-${b}";
            mode = "0400";
            content = body;
          };
    };

  mkGatewayUser = b: {
    name = "gateway-${b}";
    value =
      let
        stateDir = "${cfg.stateDirBase}/${b}";
      in {
        isSystemUser = true;
        group = "gateway-${b}";
        home = stateDir;
        createHome = false;
        shell = pkgs.bashInteractive;
      };
  };

  mkGatewayGroup = b: { name = "gateway-${b}"; value = {}; };

  mkStateDir = b:
    let
      dir = "${cfg.stateDirBase}/${b}";
      workspace = resolveGatewayWorkspace b;
      credsDir = resolveGatewayCredsDir b;
    in [
      "d ${dir} 0700 gateway-${b} gateway-${b} - -"
      "d ${workspace} 0700 gateway-${b} gateway-${b} - -"
      "d ${credsDir} 0700 gateway-${b} gateway-${b} - -"
    ];

  mkService = b:
    let
      stateDir = "${cfg.stateDirBase}/${b}";
      workspace = resolveGatewayWorkspace b;
      profile = getGatewayProfile b;
      cfgPath = "/run/secrets/rendered/openclaw-${b}.json";
      clawPkg = cfg.package;
      seedDir = profile.workspace.seedDir or cfg.documentsDir or null;
      credsDir = resolveGatewayCredsDir b;
      gatewayEnvFile = "${credsDir}/gateway.env";
      env = profile.env or {};
      effectiveSecretEnv = resolveSecretEnv profile;
      secretEnvKeys = builtins.attrNames effectiveSecretEnv;
      envDupes = lib.intersectLists (builtins.attrNames env) secretEnvKeys;
      gatewayResources = profile.resources or {};
      memoryMax =
        if (gatewayResources.memoryMax or null) != null
        then gatewayResources.memoryMax
        else cfg.resources.memoryMax;
      cpuQuota =
        if (gatewayResources.cpuQuota or null) != null
        then gatewayResources.cpuQuota
        else cfg.resources.cpuQuota;
      tasksMax =
        if (gatewayResources.tasksMax or null) != null
        then gatewayResources.tasksMax
        else cfg.resources.tasksMax;
      ioWeight =
        if (gatewayResources.ioWeight or null) != null
        then gatewayResources.ioWeight
        else cfg.resources.ioWeight;

      egressMode =
        if (config ? clawlets) && (config.clawlets ? egress) then config.clawlets.egress.mode else "smtp-only";
      proxyEnabled = egressMode == "proxy-allowlist";
      proxyPort =
        if proxyEnabled && (config.clawlets.egress.proxy.port or null) != null
        then config.clawlets.egress.proxy.port
        else 3128;
      proxyUrl = "http://127.0.0.1:${toString proxyPort}";
      gh = profile.github or {};
      ghEnabled =
        (gh.appId or null) != null
        && (gh.installationId or null) != null
        && (gh.privateKeySecret or null) != null;
      ghEnvFile = "${credsDir}/gh.env";
    in
      {
        name = "openclaw-${b}";
        value = {
          description = "OpenClaw gateway (${b})";
          wantedBy = [ "multi-user.target" ];
          after =
            [ "network-online.target" "sops-nix.service" "openclaw-gateway-token-${b}.service" ]
            ++ lib.optional ghEnabled "openclaw-gh-token-${b}.service"
            ++ lib.optional proxyEnabled "clawlets-egress-proxy.service";
          wants =
            [ "network-online.target" "sops-nix.service" "openclaw-gateway-token-${b}.service" ]
            ++ lib.optional ghEnabled "openclaw-gh-token-${b}.service"
            ++ lib.optional proxyEnabled "clawlets-egress-proxy.service";

          environment =
            if envDupes != []
            then throw "services.openclawFleet.gatewayProfiles.${b}.env has keys that conflict with secret env vars: ${lib.concatStringsSep "," envDupes}"
            else {
              OPENCLAW_NIX_MODE = "1";
              OPENCLAW_STATE_DIR = stateDir;
              OPENCLAW_CONFIG_PATH = cfgPath;
              HOME = stateDir;
            }
            // lib.optionalAttrs cfg.disableBonjour { OPENCLAW_DISABLE_BONJOUR = "1"; }
            // lib.optionalAttrs (cfg.hardening.nodeExecMem == "jitless") { NODE_OPTIONS = "--jitless"; }
            // lib.optionalAttrs (seedDir != null) {
              CLAWLETS_GATEWAY_ID = b;
              CLAWLETS_WORKSPACE_DIR = workspace;
              CLAWLETS_SEED_DIR = toString seedDir;
              CLAWLETS_TOOLS_MD = "/etc/clawlets/tools.md";
            }
            // lib.optionalAttrs proxyEnabled {
              HTTP_PROXY = proxyUrl;
              HTTPS_PROXY = proxyUrl;
              ALL_PROXY = proxyUrl;
              http_proxy = proxyUrl;
              https_proxy = proxyUrl;
              all_proxy = proxyUrl;
              NO_PROXY = "localhost,127.0.0.1,::1";
              no_proxy = "localhost,127.0.0.1,::1";
            }
            // env
            ;

          serviceConfig = {
            User = "gateway-${b}";
            Group = "gateway-${b}";
            WorkingDirectory = stateDir;

            ExecStartPre = lib.optionals (seedDir != null) [
              "/etc/clawlets/bin/seed-workspace"
              "/etc/clawlets/bin/sync-managed-docs"
            ];
            ExecStart = "${clawPkg}/bin/openclaw gateway";

            Restart = "always";
            RestartSec = "3";

            EnvironmentFile = lib.flatten [
              config.sops.templates."openclaw-${b}.env".path
              gatewayEnvFile
              (lib.optional ghEnabled "-${ghEnvFile}")
            ];

            NoNewPrivileges = true;
            PrivateTmp = true;
            PrivateDevices = true;
            ProtectSystem = "strict";
            ProtectHome = true;
            ProtectProc = "invisible";
            ProcSubset = "pid";
            ProtectKernelTunables = true;
            ProtectKernelModules = true;
            ProtectKernelLogs = true;
            ProtectControlGroups = true;
            ReadWritePaths = lib.unique [ stateDir workspace ];
            UMask = "0077";

            CapabilityBoundingSet = "";
            AmbientCapabilities = "";
            LockPersonality = true;
            LimitCORE = 0;
            # Node/V8 JIT needs to toggle executable memory permissions.
            MemoryDenyWriteExecute = cfg.hardening.nodeExecMem != "jit";
            RestrictAddressFamilies = [ "AF_INET" "AF_INET6" "AF_NETLINK" "AF_UNIX" ];
            RestrictNamespaces = true;
            RestrictSUIDSGID = true;
            RestrictRealtime = true;
            SystemCallArchitectures = "native";
          }
          // lib.optionalAttrs (memoryMax != null) { MemoryMax = memoryMax; }
          // lib.optionalAttrs (cpuQuota != null) { CPUQuota = cpuQuota; }
          // lib.optionalAttrs (tasksMax != null) { TasksMax = tasksMax; }
          // lib.optionalAttrs (ioWeight != null) { IOWeight = ioWeight; }
          // lib.optionalAttrs proxyEnabled {
            IPAddressDeny = "any";
            IPAddressAllow = [ "127.0.0.1" "::1" ];
          };
        };
      };

  mkSecretFileEntry = entry:
    let
      secretName = toString entry.secretName;
      targetPath = toString entry.targetPath;
      owner = toString entry.owner;
      group = toString entry.group;
      mode = toString entry.mode;
    in
      {
        inherit secretName targetPath owner group mode;
        value = (mkSopsSecretFor secretName) // { inherit owner group mode; path = targetPath; };
      };

  isUnsafeTargetPath = targetPath:
    (lib.hasInfix "/../" targetPath)
    || (lib.hasSuffix "/.." targetPath)
    || (lib.hasInfix "\u0000" targetPath);

  validateTargetPath = { context, prefix, targetPath }:
    if isUnsafeTargetPath targetPath
    then builtins.throw "${context}targetPath must not contain /../, end with /.., or include NUL"
    else if lib.hasPrefix prefix targetPath
    then null
    else builtins.throw "${context}targetPath must be under ${prefix}";

  secretFileEntries =
    let
      fleetSpecs = cfg.secretFiles or {};
      fleetIds = builtins.attrNames fleetSpecs;
      fleetEntries = map (id:
        let
          spec = fleetSpecs.${id};
          targetPath = toString (spec.targetPath or "");
          _ = validateTargetPath {
            context = "services.openclawFleet.secretFiles.${id}.";
            prefix = "/var/lib/clawlets/";
            inherit targetPath;
          };
          owner =
            if (spec.owner or null) != null then spec.owner else "root";
          group =
            if (spec.group or null) != null then spec.group else "root";
          mode =
            if (spec.mode or null) != null then spec.mode else "0400";
        in
          {
            scope = "fleet";
            fileId = id;
            secretName = spec.secretName;
            inherit targetPath owner group mode;
          }
      ) fleetIds;

      gatewayEntries = lib.concatLists (map (b:
        let
          profile = getGatewayProfile b;
          gatewaySpecs = profile.secretFiles or {};
          ids = builtins.attrNames gatewaySpecs;
          prefix = "/var/lib/clawlets/secrets/gateways/${b}/";
        in
          map (id:
            let
              spec = gatewaySpecs.${id};
              targetPath = toString (spec.targetPath or "");
              _ = validateTargetPath {
                context = "services.openclawFleet.gatewayProfiles.${b}.secretFiles.${id}.";
                inherit prefix targetPath;
              };
              owner =
                if (spec.owner or null) != null then spec.owner else "gateway-${b}";
              group =
                if (spec.group or null) != null then spec.group else "gateway-${b}";
              mode =
                if (spec.mode or null) != null then spec.mode else "0400";
            in
              {
                scope = "gateway";
                gateway = b;
                fileId = id;
                secretName = spec.secretName;
                inherit targetPath owner group mode;
              }
          ) ids
      ) cfg.gateways);
    in
      fleetEntries ++ gatewayEntries;

  secretFileSecrets =
    let
      go = acc: entry:
        let
          normalized = mkSecretFileEntry entry;
          key = normalized.secretName;
          prev = acc.${key} or null;
        in
          if prev != null
          then builtins.throw "secretFiles: duplicate secretName ${key} (must be unique across services.openclawFleet.secretFiles and gatewayProfiles.<gateway>.secretFiles)"
          else acc // { "${key}" = normalized.value; };
    in
      lib.foldl' go {} secretFileEntries;

  secretFileTmpfilesRules =
    let
      mkRule = entry:
        let
          dir = builtins.dirOf (toString entry.targetPath);
          isGateway = entry.scope == "gateway";
          owner = if isGateway then "root" else "root";
          group = if isGateway then "gateway-${entry.gateway}" else "root";
          mode = if isGateway then "0750" else "0750";
        in
          "d ${dir} ${mode} ${owner} ${group} - -";
    in
      lib.unique (map mkRule secretFileEntries);

  perGatewaySkillSecrets = lib.mkMerge (map mkGatewaySkillSecrets cfg.gateways);
  perGatewayTemplates = lib.mkMerge (map mkTemplate cfg.gateways);
in
{
  inherit
    mkGatewayUser
    mkGatewayGroup
    mkStateDir
    mkService
    secretFileSecrets
    secretFileTmpfilesRules
    perGatewaySkillSecrets
    perGatewayTemplates;
}
