{ config, lib, pkgs, defs, botConfig }:

let
  inherit (defs)
    cfg
    getBotProfile
    resolveBotWorkspace
    resolveBotCredsDir
    mkSopsSecretFor
    buildEffectiveSecretEnv;

  inherit (botConfig) mkBotConfig;

  resolveSecretEnv = profile:
    let
      baseEnv = buildEffectiveSecretEnv profile;
      allowlist = profile.secretEnvAllowlist or null;
    in
      if allowlist == null
      then baseEnv
      else lib.filterAttrs (k: _: lib.elem k allowlist) baseEnv;

  mkBotSkillSecrets = b:
    let
      profile = getBotProfile b;
      effectiveSecretEnv = resolveSecretEnv profile;
      secretEnvSecrets = builtins.attrValues effectiveSecretEnv;
      githubSecrets =
        lib.optional ((profile.github.privateKeySecret or null) != null) profile.github.privateKeySecret;
      allSecrets = lib.unique (lib.filter (s: s != null && s != "") (
        githubSecrets
        ++ secretEnvSecrets
      ));
    in
      builtins.listToAttrs (map (secretName: { name = secretName; value = mkSopsSecretFor secretName; }) allSecrets);

  mkTemplate = b:
    {
      "clawdbot-${b}.json" = {
        owner = "bot-${b}";
        group = "bot-${b}";
        mode = "0400";
        # Important: keep template content pure at eval time.
        # `builtins.readFile (pkgs.formats.json.generate ...)` forces a local build/eval-store write,
        # which breaks remote-build workflows on hosts that reject unsigned local store paths.
        content = builtins.toJSON (mkBotConfig b);
      };
      "clawdbot-${b}.env" =
        let
          profile = getBotProfile b;
          effectiveSecretEnv = resolveSecretEnv profile;
          envKeys = lib.sort (a: b: a < b) (builtins.attrNames effectiveSecretEnv);
          lines = lib.concatLists (map (k:
            let
              secretName = toString (effectiveSecretEnv.${k} or "");
            in
              if secretName == "" then [ ] else [ "${k}=${toString config.sops.placeholder.${secretName}}" ]
          ) envKeys);
          body = lib.concatStringsSep "\n" ([ "# Generated by clawlets (sops-nix template)" ] ++ lines) + "\n";
        in
          {
            owner = "bot-${b}";
            group = "bot-${b}";
            mode = "0400";
            content = body;
          };
    };

  mkBotUser = b: {
    name = "bot-${b}";
    value =
      let
        stateDir = "${cfg.stateDirBase}/${b}";
      in {
        isSystemUser = true;
        group = "bot-${b}";
        home = stateDir;
        createHome = false;
        shell = pkgs.bashInteractive;
      };
  };

  mkBotGroup = b: { name = "bot-${b}"; value = {}; };

  mkStateDir = b:
    let
      dir = "${cfg.stateDirBase}/${b}";
      workspace = resolveBotWorkspace b;
      credsDir = resolveBotCredsDir b;
    in [
      "d ${dir} 0700 bot-${b} bot-${b} - -"
      "d ${workspace} 0700 bot-${b} bot-${b} - -"
      "d ${credsDir} 0700 bot-${b} bot-${b} - -"
    ];

  mkService = b:
    let
      stateDir = "${cfg.stateDirBase}/${b}";
      workspace = resolveBotWorkspace b;
      profile = getBotProfile b;
      cfgPath = "/run/secrets/rendered/clawdbot-${b}.json";
      clawPkg = cfg.package;
      seedDir = profile.workspace.seedDir or cfg.documentsDir or null;
      credsDir = resolveBotCredsDir b;
      gatewayEnvFile = "${credsDir}/gateway.env";
      env = profile.env or {};
      effectiveSecretEnv = resolveSecretEnv profile;
      secretEnvKeys = builtins.attrNames effectiveSecretEnv;
      envDupes = lib.intersectLists (builtins.attrNames env) secretEnvKeys;
      botResources = profile.resources or {};
      memoryMax =
        if (botResources.memoryMax or null) != null
        then botResources.memoryMax
        else cfg.resources.memoryMax;
      cpuQuota =
        if (botResources.cpuQuota or null) != null
        then botResources.cpuQuota
        else cfg.resources.cpuQuota;
      tasksMax =
        if (botResources.tasksMax or null) != null
        then botResources.tasksMax
        else cfg.resources.tasksMax;
      ioWeight =
        if (botResources.ioWeight or null) != null
        then botResources.ioWeight
        else cfg.resources.ioWeight;

      egressMode =
        if (config ? clawlets) && (config.clawlets ? egress) then config.clawlets.egress.mode else "smtp-only";
      proxyEnabled = egressMode == "proxy-allowlist";
      proxyPort =
        if proxyEnabled && (config.clawlets.egress.proxy.port or null) != null
        then config.clawlets.egress.proxy.port
        else 3128;
      proxyUrl = "http://127.0.0.1:${toString proxyPort}";
      gh = profile.github or {};
      ghEnabled =
        (gh.appId or null) != null
        && (gh.installationId or null) != null
        && (gh.privateKeySecret or null) != null;
      ghEnvFile = "${credsDir}/gh.env";
    in
      {
        name = "clawdbot-${b}";
        value = {
          description = "Clawdbot gateway (${b})";
          wantedBy = [ "multi-user.target" ];
          after =
            [ "network-online.target" "sops-nix.service" "clawdbot-gateway-token-${b}.service" ]
            ++ lib.optional ghEnabled "clawdbot-gh-token-${b}.service"
            ++ lib.optional proxyEnabled "clawlets-egress-proxy.service";
          wants =
            [ "network-online.target" "sops-nix.service" "clawdbot-gateway-token-${b}.service" ]
            ++ lib.optional ghEnabled "clawdbot-gh-token-${b}.service"
            ++ lib.optional proxyEnabled "clawlets-egress-proxy.service";

          environment =
            if envDupes != []
            then throw "services.clawdbotFleet.botProfiles.${b}.env has keys that conflict with secret env vars: ${lib.concatStringsSep "," envDupes}"
            else {
              CLAWDBOT_NIX_MODE = "1";
              CLAWDBOT_STATE_DIR = stateDir;
              CLAWDBOT_CONFIG_PATH = cfgPath;
              HOME = stateDir;
            }
            // lib.optionalAttrs cfg.disableBonjour { CLAWDBOT_DISABLE_BONJOUR = "1"; }
            // lib.optionalAttrs (cfg.hardening.nodeExecMem == "jitless") { NODE_OPTIONS = "--jitless"; }
            // lib.optionalAttrs (seedDir != null) {
              CLAWLETS_BOT_ID = b;
              CLAWLETS_WORKSPACE_DIR = workspace;
              CLAWLETS_SEED_DIR = toString seedDir;
              CLAWLETS_TOOLS_MD = "/etc/clawlets/tools.md";
            }
            // lib.optionalAttrs proxyEnabled {
              HTTP_PROXY = proxyUrl;
              HTTPS_PROXY = proxyUrl;
              ALL_PROXY = proxyUrl;
              http_proxy = proxyUrl;
              https_proxy = proxyUrl;
              all_proxy = proxyUrl;
              NO_PROXY = "localhost,127.0.0.1,::1";
              no_proxy = "localhost,127.0.0.1,::1";
            }
            // env
            ;

          serviceConfig = {
            User = "bot-${b}";
            Group = "bot-${b}";
            WorkingDirectory = stateDir;

            ExecStartPre = lib.optionals (seedDir != null) [
              "/etc/clawlets/bin/seed-workspace"
              "/etc/clawlets/bin/sync-managed-docs"
            ];
            ExecStart = "${clawPkg}/bin/clawdbot gateway";

            Restart = "always";
            RestartSec = "3";

            EnvironmentFile = lib.flatten [
              config.sops.templates."clawdbot-${b}.env".path
              gatewayEnvFile
              (lib.optional ghEnabled "-${ghEnvFile}")
            ];

            NoNewPrivileges = true;
            PrivateTmp = true;
            PrivateDevices = true;
            ProtectSystem = "strict";
            ProtectHome = true;
            ProtectProc = "invisible";
            ProcSubset = "pid";
            ProtectKernelTunables = true;
            ProtectKernelModules = true;
            ProtectKernelLogs = true;
            ProtectControlGroups = true;
            ReadWritePaths = lib.unique [ stateDir workspace ];
            UMask = "0077";

            CapabilityBoundingSet = "";
            AmbientCapabilities = "";
            LockPersonality = true;
            LimitCORE = 0;
            # Node/V8 JIT needs to toggle executable memory permissions.
            MemoryDenyWriteExecute = cfg.hardening.nodeExecMem != "jit";
            RestrictAddressFamilies = [ "AF_INET" "AF_INET6" "AF_NETLINK" "AF_UNIX" ];
            RestrictNamespaces = true;
            RestrictSUIDSGID = true;
            RestrictRealtime = true;
            SystemCallArchitectures = "native";
          }
          // lib.optionalAttrs (memoryMax != null) { MemoryMax = memoryMax; }
          // lib.optionalAttrs (cpuQuota != null) { CPUQuota = cpuQuota; }
          // lib.optionalAttrs (tasksMax != null) { TasksMax = tasksMax; }
          // lib.optionalAttrs (ioWeight != null) { IOWeight = ioWeight; }
          // lib.optionalAttrs proxyEnabled {
            IPAddressDeny = "any";
            IPAddressAllow = [ "127.0.0.1" "::1" ];
          };
        };
      };

  mkSecretFileEntry = entry:
    let
      secretName = toString entry.secretName;
      targetPath = toString entry.targetPath;
      owner = toString entry.owner;
      group = toString entry.group;
      mode = toString entry.mode;
    in
      {
        inherit secretName targetPath owner group mode;
        value = (mkSopsSecretFor secretName) // { inherit owner group mode; path = targetPath; };
      };

  isUnsafeTargetPath = targetPath:
    (lib.hasInfix "/../" targetPath)
    || (lib.hasSuffix "/.." targetPath)
    || (lib.hasInfix "\u0000" targetPath);

  validateTargetPath = { context, prefix, targetPath }:
    if isUnsafeTargetPath targetPath
    then builtins.throw "${context}targetPath must not contain /../, end with /.., or include NUL"
    else if lib.hasPrefix prefix targetPath
    then null
    else builtins.throw "${context}targetPath must be under ${prefix}";

  secretFileEntries =
    let
      fleetSpecs = cfg.secretFiles or {};
      fleetIds = builtins.attrNames fleetSpecs;
      fleetEntries = map (id:
        let
          spec = fleetSpecs.${id};
          targetPath = toString (spec.targetPath or "");
          _ = validateTargetPath {
            context = "services.clawdbotFleet.secretFiles.${id}.";
            prefix = "/var/lib/clawlets/";
            inherit targetPath;
          };
          owner =
            if (spec.owner or null) != null then spec.owner else "root";
          group =
            if (spec.group or null) != null then spec.group else "root";
          mode =
            if (spec.mode or null) != null then spec.mode else "0400";
        in
          {
            scope = "fleet";
            fileId = id;
            secretName = spec.secretName;
            inherit targetPath owner group mode;
          }
      ) fleetIds;

      botEntries = lib.concatLists (map (b:
        let
          profile = getBotProfile b;
          botSpecs = profile.secretFiles or {};
          ids = builtins.attrNames botSpecs;
          prefix = "/var/lib/clawlets/secrets/bots/${b}/";
        in
          map (id:
            let
              spec = botSpecs.${id};
              targetPath = toString (spec.targetPath or "");
              _ = validateTargetPath {
                context = "services.clawdbotFleet.botProfiles.${b}.secretFiles.${id}.";
                inherit prefix targetPath;
              };
              owner =
                if (spec.owner or null) != null then spec.owner else "bot-${b}";
              group =
                if (spec.group or null) != null then spec.group else "bot-${b}";
              mode =
                if (spec.mode or null) != null then spec.mode else "0400";
            in
              {
                scope = "bot";
                bot = b;
                fileId = id;
                secretName = spec.secretName;
                inherit targetPath owner group mode;
              }
          ) ids
      ) cfg.bots);
    in
      fleetEntries ++ botEntries;

  secretFileSecrets =
    let
      go = acc: entry:
        let
          normalized = mkSecretFileEntry entry;
          key = normalized.secretName;
          prev = acc.${key} or null;
        in
          if prev != null
          then builtins.throw "secretFiles: duplicate secretName ${key} (must be unique across services.clawdbotFleet.secretFiles and botProfiles.<bot>.secretFiles)"
          else acc // { "${key}" = normalized.value; };
    in
      lib.foldl' go {} secretFileEntries;

  secretFileTmpfilesRules =
    let
      mkRule = entry:
        let
          dir = builtins.dirOf (toString entry.targetPath);
          isBot = entry.scope == "bot";
          owner = if isBot then "root" else "root";
          group = if isBot then "bot-${entry.bot}" else "root";
          mode = if isBot then "0750" else "0750";
        in
          "d ${dir} ${mode} ${owner} ${group} - -";
    in
      lib.unique (map mkRule secretFileEntries);

  perBotSkillSecrets = lib.mkMerge (map mkBotSkillSecrets cfg.bots);
  perBotTemplates = lib.mkMerge (map mkTemplate cfg.bots);
in
{
  inherit
    mkBotUser
    mkBotGroup
    mkStateDir
    mkService
    secretFileSecrets
    secretFileTmpfilesRules
    perBotSkillSecrets
    perBotTemplates;
}
